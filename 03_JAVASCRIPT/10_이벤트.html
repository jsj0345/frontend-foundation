<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        .area{
            border: 1px solid black;
        }
    </style>
</head>
<body>

    <!-- 내일 시험 보기 전에 알아두면 좋은 것들-->

    <h1>이벤트</h1>

    <h3>고전 이벤트 모델 (기본 이벤트 모델)</h3>

    <p>
        요소 객체에 이벤트 속성 접근하여 이벤트 핸들러를 연결하는 방식 <br>
        이벤트를 제거할 수 있다. (해당 이벤트 속성에 null 처리)
    </p>

    <!--btn#btn${확인}*2-->
    <button id="btn1">확인</button>
    <button id="btn2">확인</button>

    <div class="area" id="area1"></div>

    <script>

       let area1 = document.querySelector("#area1");

       let btn1 = document.querySelector("#btn1");

       btn1.onclick = function() {
          area1.innerHTML += "btn1이 클릭되었습니다.";
       };

       let btn2 = document.querySelector("#btn2");

       btn2.onclick = function() {
          area1.innerHTML += "btn2가 클릭되었습니다. <br>";
          area1.innerHTML += "btn1에 있는 이벤트핸들러를 제거합니다. <br>";
          //btn1에 작성된 이벤트핸들러 제거하기 
          btn1.onclick = null; 
       }

    </script>

    <h3>인라인 이벤트 모델</h3>
    <p>
        요소 내부에 직접적으로 이벤트 속성을 제시하여 실행할 내용을 정의하는 방식 <br>
        주로 script 태그 내에 정의 되어 있는 선언적 함수를 호출하는 방식을 선호
    </p>

    <button onclick="test1();">확인</button>

    <!--
      요소내부에 직접적으로 이벤트를 기술하면 실행이 가능하지만 가독성,유지보수성을 해치기 때문에
      사용하지 않음. 정말 간단한 코드일 경우만 가끔 사용된다 (권장하지 않음)
    -->

    <button onclick="document.querySelector('#area2').innerHTML += '두번째버튼 클릭';">확인</button>

    <div id="area2" class="area"></div>

    <script>
        function test1() {
            document.querySelector("#area2").innerHTML += "인라인버튼 클릭";
        }
    </script>


    <h3>표준 이벤트 모델(addEventListener)</h3>

    <input type="text" id="input1"> <br>
    <input type="text" id="input2"> <br>
    <button id="btn">버튼</button> <br>

    <script>

        let input1 = document.querySelector("#input1");
        let input2 = document.querySelector("#input2");

        /*

        //고전 이벤트 모델 방식 
        input1.onclick = function(){
            input1.value = "클릭됨";
        }

        //해당 요소에서 다른 요소로 포커스가 옮겨질때 동작하는 이벤트 
        input1.onblur = function(){
            input1.value = "어디가세요";
        }

        //해당 요소에 마우스가 올라갔을때
        input2.onmouseenter = function() {
            input2.style.backgroundColor = 'blue';
        }

        //해당 요소에서 마우스가 벗어났을때
        input2.onmouseleave= function() {
            input2.style.backgroundColor = 'red';
        }

        //해당 요소에 포커스되었을때
        input2.onfocus = function(){
            input1.value = "";
        }

        */

        let btn = document.querySelector("#btn");


        //표준 이벤트 모델 방식
        //대상.addEventListener("이벤트 동작",이벤트 핸들러(함수))
        input1.addEventListener("click",function(e){ // e라는 이벤트 객체를 전달 받기
            console.log(e); 
            console.log(e.target); // 이벤트 동작 대상 

        });

        /*
        e는 브라우저가 이벤트가 발생했을 때 자동으로 만들어서

        핸들러 함수로 전달하는 "이벤트 정보 덩어리" 객체다.

        "어떤 이벤트가 언제, 어디서, 어떤 상황에서 일어났는지"에 대한 모든

        정보를 담고 있는 객체다. 

        e.target -> 이벤트가 실제로 발생한 요소를 가리킴. 

        결론 e -> 이벤트가 발생했을 때 그 이벤트에 관한 모든 정보를 가지고 있는 객체 
        */

        //이벤트를 걸고자 하는 요소객체.addEventListener("이벤트명", 이벤트핸들러(함수))
        btn.addEventListener("click", function(){

            alert("표준 이벤트 모델");

        });

        //해당 요소에 다른 이벤트도 걸어주기
        btn.addEventListener("mouseenter",function(){
            btn.style.backgroundColor = 'skyblue';
        });

        //해당요소에 마우스 벗어났을때
        btn.addEventListener("mouseleave", function(){
            btn.style.borderRadius = '50px';
            btn.style.backgroundColor = 'blue';
            btn.style.color = 'white';
        });

        //같은 이벤트에 다른 이벤트 핸들러 넣기
        btn.addEventListener("click",function(){
            btn.innerHTML = '눌림';
        });

    </script>


    <h2>2.현재 이벤트가 발생한 해당 요소 객체에 접근하는 방법</h2>

    <button id="btn4">고전 이벤트 방식</button>
    <button id="btn5">표준 이벤트 방식</button>

    <button onclick="test2();">인라인 이벤트 방식</button>
    <button onclick="test3(this);">인라인 이벤트 방식2</button>

    <!--
    옛날 브라우저에서는 window.event가 이벤트 객체처럼 동작해서 e와 거의 같은 역할을 했지만, 
    최신 브라우저에서는 window.event가 더 이상 표준이 아니기 때문에 의도대로 동작하지 않는 별개의 개념이 되었다.
     
    이벤트 핸들러는 function(e) {...} 라고 알면되고

    "브라우저가 호출해주는 함수"이다. 

    작동 흐름 

    1. 사용자가 버튼을 클릭함.
    2. 브라우저가 "클릭 이벤트 객체"를 생성함. (PointerEvent)
    3. 브라우저가 등록된 핸들러 함수를 찾아서 호출함. 
    4. 그때 e(이벤트 객체)를 함수에 넣어줌 

    브라우저가 이벤트 핸들러 함수를 찾아서 호출할때 이벤트에 관한 정보를 

    e에 넣어주는것임. 

    -->

    <script>
        //고전이벤트 방식
        document.querySelector("#btn4").onclick = function(e){
            //이벤트가 발생했을때 해당 이벤트 정보를 가지고 있는 객체
            //window.event
            console.log(window.event);
            console.log(window.event.target); // 이벤트가 발생한 대상  

            //이벤트 핸들러 내부적으로 이벤트가 발생했을때
            //매개변수로 event 객체가 전달된다(첫번째 인자값)
            console.log(e);
            console.log(e.target);

            //이벤트 핸들러에서 this는 해당 이벤트가 발생한 요소객체를 지정한다.
            console.log(this); 

            //window.event.target == e.target == this
            //각 접근방법을 이용하여 속성 변경해보기 
            window.event.target.style.backgroundColor = 'yellowgreen';
            e.target.style.color = 'white';
            e.target.style.border = '2px solid red';

        }

        //표준 이벤트 모델 방식
        document.querySelector("#btn5").addEventListener("click",function(e){
            //console.log(window); -> 여기서는 event가 undefined임 왜그러냐면
            //최신 브라우저에서는 정식 지원이 아니라 비공식적으로 잠깐 넣는다.
            //window.event를 표준으로 지원하지 않는다.
            //그래서 전역(window 창에서 찍으면) 당연히 undefined. 
            console.log(window.event.target);
            console.log(e.target);
            console.log(this);

        });

        //인라인 이벤트 모델 방식
        function test2(e) { //선언적 함수에서 이벤트 객체를 전달받지 않고 전달한 인자값이 있다면 받게된다(매개변수)
            console.log(e); // undefined
            console.log(window.event); // 이벤트 객체 (이것도 실제로 window를 까서 보면 event는 undefined임 최신 버전이랑 호환이 안된다.)
            console.log(this); // window 객체
            console.log(this.event); // window 객체의 event속성 (target시 현재 요소객체)
        }


        //인라인 이벤트 모델 방식(this로 요소 전달)
        function test3(el) {
            console.log(el);
            console.log(window.event);
            console.log(this);
            console.log(this.event);

        }

    </script>

    <hr>  

    <h2>3.태그별 기본 이벤트 제거하기</h2>

    <p>
        기본적으로 이벤트를 가지고 있는 요소 <br>
        a 태그 : 클릭시 href에 제시되어 있는 url을 요청하는 기본 이벤트 보유 <br>
        form 태그내의 submit 버튼 : 클릭시 사용자가 입력한 정보들을 action에 제시한 url로 제출 <br>
        요청하는 기본 이벤트 보유 <br><br>
        태그 내에 기본적인 이벤트 실행을 막고자 한다면 <br>
        이벤트 핸들러의 return 값을 false로 작성한다.
    </p>

    <a href="https://www.naver.com" onclick="return test4();">네이버로 이동</a>

    <script>
        function test4() {
            let flag = confirm("이동 할래요 말래요");

            return flag; 
        }
    </script>

    <br><br>

    <form action="test.do">
        <fieldset>
            <legend>회원가입</legend>
            아이디 : <input type="text" name="userId" id="userId"> <br>
            <span style="font-size:small;">5~12자로 입력</span>
            비밀번호: <input type="password" name="userPwd" id="userPwd"> <br>
            비밀번호 확인: <input type="password" id="pwdCheck"> <br>

            <input type="submit" value="회원가입" onclick="return checking();">

        </fieldset>

    </form>

    <script>
        //아이디는 5~12자로 작성하고 비밀번호와 비밀번호 확인이 같지 않은 상황에서는
        //서버에 submit 요청이 되지 않도록 처리하기
        //버튼을 눌렀을때 위 조건을 만족하는 경우에만 서버에 요청처리 될 수 있도록 수행하기
        //함수명,변수명 자유

        let userId = document.querySelector("#userId");
        let userPwd = document.querySelector("#userPwd");
        let pwdCheck = document.querySelector("#pwdCheck");

        function checking() {
            if(userId.value.length>=5 && userId.value.length<=12) {
              if(userPwd.value != "" && pwdCheck.value!= "") { //공백일땐 같은것으로 처리됨. 제외시키자. 
                if(userPwd.value == pwdCheck.value) {
                    return true; 
                } 
              }  
            } 
            return false; 
        }
    </script>
    

    <br><br><br><br><br><br><br><br><br><br>
</body>
</html>